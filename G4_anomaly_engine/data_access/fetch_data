"""
G4 — Accès aux données
Lit depuis power_consumption selon les contrats d'interface.
Colonnes utilisées : exactement celles du data_dictionary.md du projet.
"""

import pandas as pd
from common.db import get_connection
import logging

logger = logging.getLogger("G4")

# Colonnes features exactes du dictionnaire de données
FEATURE_COLUMNS = [
    "global_active_power_kw",
    "global_reactive_power_kw",
    "voltage_v",
    "global_intensity_a",
    "sub_metering_1_wh",
    "sub_metering_2_wh",
    "sub_metering_3_wh",
]


def fetch_historical(limit: int = 10000) -> pd.DataFrame:
    """
    Récupère des données historiques pour l'entraînement du modèle.
    Prend les anciennes lignes (déjà insérées depuis longtemps) comme données "saines".
    """
    query = f"""
        SELECT id, {', '.join(FEATURE_COLUMNS)}
        FROM power_consumption
        WHERE {' AND '.join([f'{col} IS NOT NULL' for col in FEATURE_COLUMNS])}
        ORDER BY ts ASC
        LIMIT %s
    """
    conn = get_connection()
    try:
        df = pd.read_sql_query(query, conn, params=(limit,))
        logger.info(f"fetch_historical → {len(df)} lignes récupérées")
        return df
    finally:
        conn.close()


def fetch_unscored(limit: int = 200) -> pd.DataFrame:
    """
    Récupère les lignes non encore scorées (scored_at IS NULL).
    C'est le contrat d'interface G4 : on lit uniquement ces lignes.
    """
    query = f"""
        SELECT id, {', '.join(FEATURE_COLUMNS)}
        FROM power_consumption
        WHERE scored_at IS NULL
          AND {' AND '.join([f'{col} IS NOT NULL' for col in FEATURE_COLUMNS])}
        ORDER BY ts ASC
        LIMIT %s
    """
    conn = get_connection()
    try:
        df = pd.read_sql_query(query, conn, params=(limit,))
        logger.info(f"fetch_unscored → {len(df)} lignes non scorées")
        return df
    finally:
        conn.close()
